"""
    CS051P Final Programming Assignment: Analyzing Airbnb Data.

    Author: Collins Kariuki.

    Date:   10th December 2021

    The goal of this assignment is to put into practice what I have learned in CSCI 051, using list comprehensions,
    functions, loops data analyses and visualisation techniques, with regards to analysing data from Airbnb, a company
    which runs an online marketplace that lets people rent out their houses, rooms, apartments,
    RVs, spare rooms, extra beds. For this assignment, I shall seek to answer the following questions:
        1. Is there any correlation between the price of a listing and the overall satisfaction?
        2. Do hosts typically have multiple listings at the same time?
        3. How do the prices of a rental change over time?
        4. How different are the prices in different neighborhoods?
    I shall also plot results generated from answering one of the questions above.
"""

# imports the scipy package
from scipy.stats.stats import spearmanr
# imports the matplotlib package
import matplotlib.pyplot as plt


def price_satisfaction(filename):
    """
    takes a string containing the name of a file and returns a list of lists which contains information regarding price
    and overall satisfaction regarding a particular room

    :param filename (string): name of the file

    :return (list): list of lists where the first element in each sublist is the price (in $US) for a night stay for a
    particular room and the second element of the sublist is the overall satisfaction - the average rating (out of five)
    that the listing has received from those visitors who left a review.
    """

    # initialises csv_data list
    csv_data = []
    # initialises fin_list
    price_satisfaction_list = []
    # opens file
    with open(filename, 'r', encoding='utf-8') as file_in:
        # reads first line of file, splits it where there is a comma and finds length of resulting list
        header_length = len(file_in.readline().split(','))
        # reads through each of the remaining lines in the file
        remaining_lines = file_in.readlines()
        # loops through each of the remaining lines in the file
        for line in remaining_lines:
            # splits each of remaining lines in file and creates list containing words present in the line
            words = line.split(',')
            # ensures that length of words is same as header_length
            if len(words) == header_length:
                # appends words into csv.data
                csv_data.append(words)

        # loops through the elements in csv_data
        for i in csv_data:
            # ensures number of reviews is positive
            if int(i[8]) > 0:
                # for item in csv_data:
                price_satisfaction_list.append([float(i[13]), float(i[9])])
    # returns price_satisfaction_list
    return price_satisfaction_list


def correlation(l):
    """
    takes nested list generated by the price_satisfaction function and returns a tuple containing correlation between
    the price and the overall satisfaction

    :param l (list): nested list returned by the price_satisfaction function. This list has price data and overall
    satisfaction data

    :return (tuple): contains the correlation between the price and overall satisfaction. The first value of the tuple
    is the correlation value between the price data and overall satisfaction data and the second value in the tuple is
    the pvalue between the 2 sets of data.
    """
    # initialises list for the price data
    price_data = []
    # initialises list for the overall rating data
    overall_rating_data = []
    # loops through every sublist in l
    for sublist in l:
        # loops through each element in each sublist
        for i in range(len(sublist) - 1):
            # appends price data in l to price_data list
            price_data.append(sublist[i])
            # appends overall satisfaction data in l to overall_rating_data list
            overall_rating_data.append(sublist[i + 1])

    # computes the correlation between price_data and overall_rating_data
    spearmanr_result = spearmanr(price_data, overall_rating_data)
    # calculates correlation on spearmanr_result
    correlation_value = spearmanr_result.correlation
    # calculates pvalue on spearmanr_result
    pvalue = spearmanr_result.pvalue
    # sets elements of correlation_tuple
    correlation_tuple = (correlation_value, pvalue)
    # returns correlation_tuple
    return correlation_tuple


def host_listings(filename):
    """
    takes a string which is the name of a file and returns a dictionary where the keys are host ids and the values are
    room ids linked to that particular host.

    :param filename (string): name of the file
    :return (dictionary): dictionary where the keys are host ids (ints) and the values are room ids (ints) linked to
    that particular host.
    """
    # initialises host_listings_dict
    host_listings_dict = {}
    # initialises csv_data list
    csv_data = []
    # opens file
    with open(filename, 'r', encoding='utf-8') as file_in:
        # reads first line of file, splits it where there is a comma and finds length of the resulting list
        header_length = len(file_in.readline().split(','))
        # reads through each of the remaining lines in file
        remaining_lines = file_in.readlines()
        # loops through each of the remaining lines in file
        for line in remaining_lines:
            # splits each of remaining lines in file and creates a list containing words present in the line
            words = line.split(',')
            # ensures that the length of words is same as length of words in header list
            if len(words) == header_length:
                # appends words into csv.data
                csv_data.append(words)

        # loops through the elements in csv_data
        for i in csv_data:
            # checks to see whether host_id is in host_listings_dict
            if int(i[2]) in host_listings_dict.keys():
                # checks to see whether room ids are part of the values of host_listings_dict
                if int(i[0]) not in host_listings_dict[int(i[2])]:
                    # adds room ids to list linked to certain key if price isn't present in values of host_listings_dict
                    host_listings_dict[int(i[2])].append(int(i[0]))
            # sets other condition for what to do when the host id is not among the keys of host_listings_dict
            else:
                # sets the key:value pair in the host_listings_dict when host id is not in host_listings_dict
                host_listings_dict[int(i[2])] = [int(i[0])]
    # returns the dictionary of key(host ids):value(list of room ids of a particular host) pairs
    return host_listings_dict


def num_listings(d):
    """
    takes the dictionary returned by the host_listings function and returns a list l where l[i] is the number of hosts
    that have exactly i listings.

    :param d (dictionary): dictionary returned by the host_listings function where  the keys are host ids (ints) and the
    values are room ids (ints) linked to that particular host.

    :return (list): a list l where l[i] refers to the number of hosts that have exactly i listings.
    """

    # initializes the num_listings_list
    num_listings_list = []
    # loops over the values of d
    for i in d.values():
        # adds the length of the list-values to num_listings_list
        num_listings_list.append(len(i))
    # sorts the elements in num_listings_list
    num_listings_list.sort()
    # identifies and equates the largest element in num_listings_list to max_target_list
    max_target_list = num_listings_list[-1]
    # adds one to max_target_list
    max_target_list = max_target_list + 1
    # initializes a list (which serves as a counter) of zeros where number of zeros is equal to max_target_list
    initialising_list = [0] * max_target_list
    # establishes loop through the range of max_target_list
    for i in range(max_target_list):
        # loops through the values of d
        for item in d.values():
            # checks to see whether length of the values of d is equal to i.
            if len(item) == i:
                # counts the number of hosts for each index in initialising_list
                initialising_list[i] = initialising_list[i] + 1
    # returns the initialising_list (the counter list)
    return initialising_list


def room_prices(filename_list, roomtype):
    """
    takes a list of filenames and a room type and returns a dictionary where the keys are room ids and the values are a
    list of price for that listing over time, from oldest data to the most recent.
    :param filename_list (list): this is a list of filenames which are strings
    :param roomtype (string): one of the choices, 'Entire home/apt', 'Private room' and 'Shared room' that one can enter
    :return (dictionary): where the keys are room ids and the values are a
    list of price for that listing over time, from oldest data to the most recent.
    """

    def sort_files(files):
        """
        this helper function sorts the files in filename_list in ascending calendar order, that is, from earliest date
        to the latest date
        :param files (list): takes a list of filenames
        :return (list): returns a list of sorted filenames in ascending calendar order
        """
        # initializes the dates_list
        dates_list = []
        # loops through the files in files
        for name in files:
            # slices the dates from the filename in filename_lis and appends them to dates_list
            dates_list.append(name[-14:-4])
        # sorts the dates in dates_list
        dates_list.sort()

        # initialise the sort_files list
        sorted_files = []
        # loop through each date in dates_list
        for date in dates_list:
            # loop through each file in files
            for file in files:
                # check to see whether date is in the names of the files in files
                if date in file:
                    # append the filenames in the correct ascending calendar order to sorted_files
                    sorted_files.append(file)
        # return sorted_files
        return sorted_files

    # initializes the room_prices_dict
    room_prices_dict = {}
    # calls sort_files() on filename_list to sort the filenames in filename_list in ascending calendar order
    sorted_filename_list = sort_files(filename_list)
    # opens file
    for filename in sorted_filename_list:
        # opens every file in the sorted filename list
        with open(filename, 'r', encoding='utf-8') as file_in:
            # reads the first line of the file, splits it where there is a comma and finds length of the resulting list
            header_length = len(file_in.readline().split(','))
            # read through each of the remaining lines in the file
            remaining_lines = file_in.readlines()
            # loop through each of the remaining lines in the file
            for line in remaining_lines:
                # split each of the remaining lines in the file and creates a list containing words present in the line
                words = line.split(',')
                # ensure that the length of words is same as length of words in header list
                if len(words) == header_length and words[3] == roomtype:
                    # casts the room ids to integers
                    words[0] = int(words[0])
                    # casts the prices to floats
                    words[13] = float(words[13])
                    # checks to see whether the room ids are in the keys of room_prices_dict
                    if words[0] in room_prices_dict.keys():
                        # adds prices to list linked to certain key if price isn't present in values of room_prices_dict
                        room_prices_dict[words[0]].append(words[13])
                    # sets other condition for what to do when room id is not among the keys of room_prices_dict
                    else:
                        # sets the key:value pair in the room_prices_dict when room id is not in room_prices_dict
                        room_prices_dict[words[0]] = [words[13]]
    # returns room_prices_dict
    return room_prices_dict


def price_change(d):
    """
    takes the dictionary returned by the room_prices function and returns a tuple containing maximum percentage change
    in price, the starting price for the property that has the maximum percentage change and the ending price for the
    property that has the maximum percentage change

    :param d (dictionary): dictionary returned by the room_prices function
    :return (tuple): tuple with three elements in the following order:
        1. maximum percentage change for the set of properties in s
        2. the starting price for the property that has the maximum percentage change
        3. the ending price for the property that has the maximum percentage change
    """

    # initialises percent_list
    percent_list = []
    # loops through the values of d
    for value in d.values():
        # calculates the percentage change in price for any given listing
        percent_change = ((value[-1] - value[0]) / value[0]) * 100
        # appends the calculated percentage change in price for each listing to percent_list
        percent_list.append(percent_change)
    # sets the index of the largest value in percent_list to index_max
    index_max = percent_list.index(max(percent_list))
    # creates a list of the keys in d
    dict_list = list(d)
    # identifies the value in d that corresponds to the maximum percentage change in price
    max_room_id = dict_list[index_max]
    # returns the required tuple
    return max(percent_list), d[max_room_id][0], d[max_room_id][-1]


def price_by_neighborhood(filename):
    """
    takes the name of a file and returns a dictionary where each key is a neighborhood in the file and the value for a
    key is the average price for an 'Entire home/apt' listing in that neighborhood.
    :param filename (str): the name of a file
    :return (dicstionary): where each key is a neighborhood in the file and the value for a key is the average price for
    an 'Entire home/apt' listing in that neighborhood.
    """
    # initialises price_by_neighborhood_dict
    price_by_neighborhood_dict = {}
    # opens file
    with open(filename, 'r', encoding='utf-8') as file_in:
        # reads the first line of the file, splits it where there is a comma and finds length of the resulting list
        header_length = len(file_in.readline().split(','))
        # reads through the remaining lines
        remaining_lines = file_in.readlines()
        # loops through the remaining lines
        for each_line in remaining_lines:
            # split each of the remaining lines in the file and creates a list containing words present in the line
            words = each_line.split(',')
            # casts the price to floats
            words[13] = float(words[13])
            # ensures the roomtype is "Entire home/apt" and that length of words is equal to header_length
            if words[3] == "Entire home/apt" and len(words) == header_length:
                # checks to see whether neighborhood is in the keys of price_by_neighborhood_dict
                if words[7] in price_by_neighborhood_dict.keys():
                    # adds prices to list linked to certain key if price isn't in values of price_by_neighborhood_dict
                    price_by_neighborhood_dict[words[7]].append(words[13])
                # sets other condition for what to do when neighborhood is not among keys of price_by_neighborhood_dict
                else:
                    # sets key:value pair in price_by_neighborhood_dict when room id isn't in price_by_neighborhood_dict
                    price_by_neighborhood_dict[words[7]] = [words[13]]

    # initialises average_list
    average_list = []
    # loops through the elements of the list of price_by_neighborhood_dict's values
    for sublist in list(price_by_neighborhood_dict.values()):
        # initialises total
        total = 0
        # loops through each element in sublist
        for number in sublist:
            # adds number to total
            total = total + number
        # calculates average
        average = total / len(sublist)
        # appends average to average_list
        average_list.append(average)

    # converts price_by_neighborhood_dict to a list and assigns it to key_list
    key_list = list(price_by_neighborhood_dict.keys())
    # creates key:value pairs for price_by_neighborhood_dict2
    price_by_neighborhood_dict2 = {key_list[i]: average_list[i] for i in range(len(key_list))}
    # returns price_by_neighborhood_dict2
    return price_by_neighborhood_dict2


def plot_data():
    """
    generates a bar graph plot of part II's results.
    """
    # calls num_listings on an example of a New York file and assigns it to plot_data_list
    plot_data_list = num_listings(host_listings('tomslee_airbnb_new_york_1129_2017-04-21.csv'))
    # initialises index_list
    index_list = []
    # loops through the the length of plot_data_list
    for element in range(0, len(plot_data_list)):
        # appends element to index_list
        index_list.append(element)
    # assigns index_list to x_values
    x_values = index_list
    # assigns plot_data_list to y_values
    y_values = plot_data_list
    # calls plt.bar to x_values and y_values and plots them against each other
    plt.bar(x_values, y_values, color='red', width=0.5)
    # labels the x-axis
    plt.xlabel('Number of listings')
    # labels the y-axis
    plt.ylabel('Number of hosts')
    # assigns a title to the bar graph plot
    plt.title('Number of listings for New York in April 2017')
    # shows the actual plot
    plt.show()


def main():
    """
    calls plot_data function
    """
    # calls plot_data
    plot_data()


if __name__ == '__main__':
    main()
